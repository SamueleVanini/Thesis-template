% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Resoconto del progetto}
\label{cap:resoconto-progetto}
%**************************************************************

\intro{Nel corso di questo capitolo si presenta un resoconto del progetto, descrivendone gli aspetti nel dettaglio. Si illustrano le metodologie di lavoro utilizzato e le scelte
dietro lo sviluppo delle componenti ritenute più rilevanti o critiche.}

%**************************************************************
\section{Pianificazione delle attività}
In accordo con il mio \emph{tutor} interno abbbiamo stilato un piano di lavoro suddividendo gli argomenti da affrontare di settimana in settimana, indicando poi per ciascuna settimana
le ore di lavoro e le attività che avrei svolto. \\
Tale piano viene riportato di seguito nella tabella \ref{tab:piano-di-lavoro}.
%Viene riportato di seguito il piano di lavoro in forma tabellare:

\begin{table}[!h]
\begin{tabularx}{\textwidth}{|c|X|}
\hline
\textbf{Ore settimanali} & \textbf{Attività svolte}\\
\hline
Prima settimana - 40 ore & Presentazione del progetto e degli attori coinvolti, predisposizione dell’ambiente di lavoro, 
formazione sugli apparati \emph{hardware} adottati e inizio studio autono sulle tecnologie adottate. \\
\hline
Seconda settimana - 40 ore & Studio autonomo su: tecnolgie e \emph{framework} adottati, teoria RFID, librerie offerte dal produttore degli apparati utilizzati \\
\hline
Terza settimana - 40 ore & Progettazione del modulo software ed implementazione delle componenti riguardanti letture tag e invio dati alla piattaforma AMP\\
\hline
Quarta settimana - 40 ore & Implementazione delle componenti riguardanti \emph{sessions} e \emph{singulation}\\
\hline
Quinta settimana - 40 ore & Implementazione delle componenti riguardanti \emph{transit time} e \emph{dwell time}\\
\hline
Sesta settimana - 40 ore & Implementanzione delle componenti riguardanti \emph{kray protocol} e gestione porte \emph{GPIO} \\
\hline
Settima settimana - 40 ore & Implementazione della componente riguardante il controllo del modulo dalla piattaforma AMP\\
\hline
Ottava settimana - 40 ore & Test approfonditi del prodotto, stesura della documentazione relativa a quanto implementato, 
stesura di un documento riassuntivo sulla tecnologia JNA e sulle librerie offerte dal produttore.\\
\hline
\end{tabularx}
\caption{Piano di lavoro}
\label{tab:piano-di-lavoro}
\end{table}

\subsection{Comunicazioni}
Durante tutta la durata le progetto ho tenuto una comunicazione attiva con tutte le figure aziendali interessate al prodotto da me sviluppato. \\
Ho tenuto giornalmente delle riunioni con il mio \emph{tutor} interno, della durata di circa 15 minuti in cui esponevo lo stato di avanzamento, riportando
quanto svolgo durante nell'ultima giornata trascorsa, i problemi sorti e le mie proposte sullo sviluppo delle componenti richieste.
Ho partecipato regolarmente alle riunioni di reparto, svolte ogni lunedì, della durata di circa un'ora in ho avuto la possibilità di rendere participi tutti
gli sviluppatori presenti del lavoro da me svolto. %e avessi adoperato tecnologie o tecniche ritenute da me di interesse collettivo.
Oltre agli incontri precedentemente citati, ho tenuto periodicamente delle revisioni del codice con uno dei dipendenti appartenente al gruppo di \emph{tech lead}
per discutere le scelte progettuali ed implementative da me fatte, questo verrà approfondito nella sezione \ref{sub-sect:revisioni-progetto}.

\subsection{Revisioni di progetto}
\label{sub-sect:revisioni-progetto}
La progettazione e lo sviluppo del progetto sono state intervallate da periodici controlli sulla qualità di quanto da me prodotto. Questi controlli erano
effettuati da me ed un sviluppatore esperto facente parte del gruppo di \emph{tech lead} presente in azienda. Durante questi incrontri tutto il codice sorgente
è stato revisionato, commendandone le caratteristiche e le scelte fatte. Al termine di questa fase, il prodotto
veniva testato tramite la simulazione di contesti reali in cui potevo effettuare test di carico e controllare l'assenza di anomalie.

%**************************************************************
\section{Analisi del progetto}
Nonostante abbia sviluppato l'intero applicativo in autonomia, ho seguito tutti i passi adoperati dal gruppo di sviluppo per la realizzazione
di un progetto interno e quindi non finalizzato ad un cliente specifico.
Questi sono elencati di seguito:
\begin{itemize}
    \item \textbf{Incontro con gli \emph{stakeholder}}: in questa fase viene fatto l’incontro tra il gruppo che andrà a sviluppare il prodotto e tutti 
    gli attori interassati al proggetto. In questa sede vengono discusse varie idea, specificando i requisiti e gli obiettivi che il prodotto dovrà 
    raggiungere;
    \item \textbf{\emph{Scouting} delle tecnologie}: dopo aver acquisito le informazioni utili relative al progetto, il gruppo di lavoro inizia a ricercare 
    le tecnologie che possono risultare più adatte a soddisfare le richieste poste dal committente, vagliando anche quelle più sperimentali ed innovative;
    \item \textbf{Studio di fattibilità}: successivamente viene fatto lo studio di fattibilità, in modo tale da poter capire se il prodotto si possa sviluppare 
    concretamente. Viene svolta anche un’analisi dei rischi e dei costi, al fine di poter presentare, a tutti gli interessati al progetto, una chiara panoramica
    di quello che ci si aspetta essere il risultato finale. In questa fase il progetto può essere scartato se considerato non abbastanza vantaggioso;
    \item \textbf{Sviluppo}: se gli attori coinvolti accettano quanto riportato dallo studio di fattibilità, allora si inizia con la fase vera 
    e propria dello sviluppo del prodotto. 
    Il lavoro viene suddiviso in tanti incrementi, come descritto nel modello Agile, così da garantirne un controllo completo. Allo stesso tempo,
    una suddivisione incrementale permette una facile esposizione dei risultati raggiunti al committente.
    \item \textbf{\emph{Testing}}: in questa fase il prodotto viene testato mediante specifici test, sia manuali che automatici, per verificarne le 
    funzionalità e assicurarsi che il prodotto abbia soddisfatto le richieste del committente.
\end{itemize}

\subsection{Funzionalità principali}
Dopo aver impostato gli incrementi, in accordo con il mio \emph{tutor} interno, ho redatto una lista di macro funzionalità che il prodotto avrebbe 
dovuto avere:
\begin{itemize}
    \item \textbf{Funzionamento autonomo}: dovendo integrare questi lettori in contesti industriali in cui il carico di lavoro risulta essere particolarmente 
    elevato, era necessario che i dispositivi potessero lavorare senza la presenza di un operatore umano, che gli azionasse e controllasse;
    \item \textbf{Tolleranza ai guasti}: operando in contesti in cui agenti fisici possono facilmente interrompere la connessione ai dispositivi, era necesserio
    identificare e gestire tali anomalie;
    \item \textbf{Configurazione a "caldo"}: necessitando di cambi di configurazione durante il suo utilizzo, il prodotto doveva poter modificare alcuni 
    parametri di configurazione senza la necessità di riavviarsi o di interrompere il flusso di lavoro in cui inserito;
    \item \textbf{Integrazione con AMP}: dovendo inviare dati alla  piattaforma utilizzata per la realizzazione dei flussi di lavoro e ricevere comandi da essa, 
    era necessario implementare una strategia di comunicazione con tale \emph{software};
\end{itemize}

\subsection{Obiettivi e requisiti chiave}

\subsubsection*{Obiettivi}
\label{sub-sub-sec:obiettivi-cap-3}
Durante la fase di stesura del Piano di Lavoro, io ed il mio \emph{tutor} interno abbiamo prefissato degli obiettivi da raggiungere entro la fine dello stage.
Di seguito sono riportati mediante una nomenclatura che li identifica univocamente:
\begin{center}
    [\textbf{classificazione}][\textbf{numero incrementale}]
\end{center}
dove il campo classificazione può avere uno dei seguenti valori:
\begin{itemize}
    \item \textbf{O}: obiettivi obbligatori, vincolanti in quanto obiettivo primario richiesto dal committente;
    \item \textbf{D}: obiettivi desiderabili, non vincolanti o strettamente necessari, ma dal riconoscibile valore aggiunto;
    \item \textbf{F}: obiettivi facoltativi, rappresentanti valore aggiunto non strettamente competitivo.
\end{itemize}
Vengono di seguito riportati in forma tabellare.
\begin{table}[h!]
    \label{tab:obiettivi}
    \begin{tabularx}{\textwidth}{ | c | X |}
    \hline
    \textbf{Obiettivi} & \textbf{Descrizione}\\
    \hline
    O01 & Dimostrazione di una piena conoscenza della teoria legata alla tecnologia RFID \\
    \hline
    O02 & Realizzazione di un modulo software pienamente funzionante che rispetti le caratteristiche desiderate dagli stakeholder \\
    \hline
    O03 & Realizzazione della documentazione su quanto implementato e sulle tecnologie utilizzate \\
    \hline
    D01 & Realizzazione di uno studio di fattibilità sul \emph{porting} del modulo realizzato all'interno dei lettori RFID \\
    \hline
    F01 & Esposizione tramite API dello stato fisico dei lettori \\
    \hline
    \end{tabularx}
    \caption{Piano di lavoro}
\end{table}

\subsubsection*{Analisi dei requisiti}
\label{sub-sec:req}
Al fine di raggiungere gli obiettivi elencati, io ed il mio \emph{tutor} interno, ci siamo concentrati nella raccorta di requisiti. Questi sono identificati
da una nomenclatura univoca, cosí composta:
\begin{center}
    \textbf{R}[\textbf{classificazione}][\textbf{tipologia}][\textbf{numero incrementale}]
\end{center}

Per \textbf{classificazione} del requisito si intende:
\begin{itemize}
    \item \textbf{O}: obbligatoro;
    \item \textbf{D}: desiderabile;
    \item \textbf{F}: facoltativo.
\end{itemize}

Per \textbf{tipologia} del requisito si intende:
\begin{itemize}
    \item \textbf{F}: funzionale;
    \item \textbf{Q}: qualitativo;
    \item \textbf{P}: prestazionale;
    \item \textbf{V}: vincolo.
\end{itemize}

Nella tabella \ref{tab:requisiti-fun} sono riportati solo i requisiti funzionali estratti dai Casi d'Uso più significativi presentati in sezione \ref{sub-sec:use-case}.
\begin{table}[!htb]
    \begin{tabularx}{\textwidth}{ | c | X | c |}
    \hline
    \textbf{Requisito} & \textbf{Descrizione} & \textbf{Fonte}\\
    \hline
    ROF1 & L'utente deve poter visionare la configurazione del lettore & UC1 \\
    \hline
    ROF2 & L'utente deve poter modificare la configurazione del lettore & UC2 \\
    \hline
    ROF3 & L'applicativo deve poter tornare in funzione in maniera autonoma a seguito di errori dovuti ala rete & UC5 \\
    \hline
    ROF4 & L'utente deve poter modificare lo stato delle porte GPIO connesse al lettore & UC3 \\
    \hline
    ROF5 & Il modulo deve inviare i dati relativi ai tag letti alla piattaforma AMP & UC4 \\
    \hline
    \end{tabularx}
    \caption{Tabella di tracciamento dei requisiti funzionali}
    \label{tab:requisiti-fun}
\end{table}
Per quanto riguarda i requisiti di vincolo, consultare la tabella \ref{tab:requisiti-vinc}.
\begin{table}[!htb]
    \begin{tabularx}{\textwidth}{ | c | X | c |}
    \hline
    \textbf{Requisito} & \textbf{Descrizione} & \textbf{Fonte}\\
    \hline
    ROV1 & Utilizzo di Java 8 per la codifica del modulo & Interna \\
    \hline
    ROV2 & Utilizzo della libreria JNA per interfacciarsi con librerie native & Interna \\
    \hline
    \end{tabularx}
    \caption{Tabella di tracciamento dei requisiti di vincolo}
    \label{tab:requisiti-vinc}
\end{table}
I requisiti qualitativi rilevati sono elencati nella tabella \ref{tab:requisiti-qual}:
\begin{table}[!htb]
    \begin{tabularx}{\textwidth}{ | c | X | c |}
    \hline
    \textbf{Requisito} & \textbf{Descrizione} & \textbf{Fonte}\\
    \hline
    ROQ1 & Il codice sorgente dev'essere versionato tramite il \emph{software} Git & Interna \\
    \hline
    ROQ2 & Dev'essere realizzato un documento riguardante le tecnologie, le scelte implementative e progettuali con relative motivazioni & Interna \\
    \hline
    \end{tabularx}
    \caption{Tabella di tracciamento dei requisiti qualitativi}
    \label{tab:requisiti-qual}
\end{table}
Infine, i requisiti prestazionali rilevati sono elencati nella tabella \ref{tab:requisiti-pre}:
\begin{table}[!htb]
    \begin{tabularx}{\textwidth}{ | c | X | c |}
    \hline
    \textbf{Requisito} & \textbf{Descrizione} & \textbf{Fonte}\\
    \hline
    ROP1 & Il modulo deve supportare la lettura di centinaia di tag simultaneamente & Interna \\
    \hline
    \end{tabularx}
    \caption{Tabella di tracciamento dei requisiti qualitativi}
    \label{tab:requisiti-pre}
\end{table}
\newpage
\subsection{Casi d'uso}
\label{sub-sec:use-case}
\begin{usecase}{1}{Visualizzazione configurazione del lettore}
\usecaseactors{Utente}
\usecasepre{L'utente è entrato all'interno di AMP ed ha lanciato il comando per visualizzare la configurazione del lettore}
\usecasedesc{AMP mette a disposizione una finestra relativa al modulo in cui lanciare comandi verso questo tra cui visualizzazione e modifica 
della configurazione del lettore}
\usecasepost{Il modulo restituisce ad AMP le informazioni riguardanti la configurazione che vengono mostrate a schermo}
\label{uc:1}
\end{usecase}

\begin{figure}[!h] 
    \centering 
    \includegraphics[width=0.9\columnwidth]{usecase/UC1} 
    \caption{Use Case - UC1: Visualizzazione configurazione del lettore}
\end{figure}

\begin{usecase}{2}{Mofidica configurazione del lettore}
\usecaseactors{Utente}
\usecasepre{L'utente è entrato all'interno di AMP ed ha lanciato il comando per modificare la configurazione del lettore}
\usecasedesc{AMP mette a disposizione una finestra relativa al modulo in cui lanciare comandi verso questo tra cui visualizzazione e modifica 
della configurazione del lettore}
\usecasepost{Il modulo restituisce ad AMP un feedback sull'esito dell'operazione e nel caso di esito positivo la configurazione inserita}
\label{uc:2}
\end{usecase}

\begin{figure}[!h] 
    \centering 
    \includegraphics[width=0.9\columnwidth]{usecase/UC2} 
    \caption{Use Case - UC2: Modifica configurazione del lettore}
\end{figure}

\begin{usecase}{3}{Modifica dello stato delle porte GPIO}
\usecaseactors{Utente}
\usecasepre{L'utente è entrato all'interno di AMP ed ha lanciato il comando per modificare lo stato delle porte GPIO}
\usecasedesc{AMP mette a disposizione una finestra relativa al modulo in cui lanciare il comando relativo alla modifica dello stato di una porta GPIO}
\usecasepost{Il modulo restituisce ad AMP un feedback sull'esito dell'operazione}
\label{uc:3}
\end{usecase}

\begin{figure}[!h] 
    \centering 
    \includegraphics[width=0.9\columnwidth]{usecase/UC3} 
    \caption{Use Case - UC3: Modifica dello stato delle porte GPIO}
\end{figure}

\begin{usecase}{4}{Visualizzazione configurazione del lettore}
\usecaseactors{Modulo, AMP}
\usecasepre{Il modulo ha raccolto dei dati che vuole mandare ad AMP}
\usecasedesc{AMP mette a disposizione un canale di comunicazione per l'invio di dati da un modulo qualsiasi ad essa}
\usecasepost{AMP restituisce al modulo un feeback sull'esito dell'operazione}
\label{uc:4}
\end{usecase}

\begin{figure}[!h] 
    \centering 
    \includegraphics[width=0.9\columnwidth]{usecase/UC4} 
    \caption{Use Case - UC4: Visualizzazione configurazione del lettore}
\end{figure}

\begin{usecase}{5}{Rispistino connessione al lettore in caso di anomalia}
\usecaseactors{Modulo}
\usecasepre{Il modulo riscontra una disconnessione dal lettore}
\usecasedesc{Il modulo periodicamente controlla l'esistenza di una connessione attiva e valida verso il lettore in operazione}
\usecasepost{Il modulo entra in uno stato di \emph{recovery} in cui cerca di ripristinare la connessione e notifica l'utente dell'accaduto}
\label{uc:5}
\end{usecase}

\subsection{Tecnologie coinvolte}
Per lo sviluppo del modulo, come accennato in sezione \ref{sub-sec:vinc-tec}, sono state utilizzate le seguenti tecnologie:
\begin{itemize}
    \item \textbf{OSGi Knopflerfish}: si tratta di un \emph{framework open-source} sviluppato da Makewave che rispecchia gli standard della OSGi Alliance.
    Questa fondazione, sovvenzionata a sua volta dalla Eclipse Foundation, si pone l'obiettivo di formalizzare l'evoluzione di tecnolgie industriali per
    la creazione di soluzioni modulari sulla piattaforma JVM.
    Knopflerfish offre molte \emph{feature} per agevolare lo sviluppo dell'applicativo, tra cui:
    \begin{itemize}
        \item Componenti per la creazione di un \emph{bundle} integrabile direttamente all'interno di AMP;
        \item Strumenti per l'accesso ad una \emph{thread pool} gestista dalle grandi performance;
        \item Un canale di cominicazione per lo scambio di dati tra i \emph{bundle}.
    \end{itemize}
    \item \textbf{JNA}: è una libreria \emph{open-source} che permette di accedere a codice nativo, ovvero scritto in un linguaggio compilato come C e C++, 
    direttamente dal codice scritto in Java. Il suo utilizzo è particolarmente adatto a contesti industriali dove si vuole permettere l'interazione con
    codice che possa operare direttamente sull'\emph{hardware} del dispositivo.
    Le principali \emph{feature} che offre per raggiungere questo intento sono:
    \begin{itemize}
        \item Conversione o rappresentazione di tipi di dati nativi nelle controparti utilizzate dalla JVM;
        \item Astrazione del paradigma di programmazione procedurale in programmazione ad oggetti;
        \item Gestione autonoma della memoria utilizzata dal codice nativo.  
    \end{itemize}
    \item \textbf{Java 8}: linguaggio di programmazione orientato agli oggetti, scelto per lo sviluppo dell'applicativo per la sua integrazione con 
    Knopflerfish. La scelta relativa alla versione è stata presa a valle di alcune considerazioni. La \emph{release} 8 infatti presenta numerose migliorie
    come l'introduzione dei metodi lambda, conservando però, tutte le aggiunte alla libreria di base riguardante il parallelismo e la concorrenza introdotte
    nella versione 7. In aggiunta a questo, l'utilizzo di questa versione avrebbe impedito il versificarsi di conflitti fra JVM differenti all'interno della
    stessa soluzione.
\end{itemize}

%Durante la fase di analisi iniziale sono stati individuati alcuni possibili rischi a cui si potrà andare incontro.
%Si è quindi proceduto a elaborare delle possibili soluzioni per far fronte a tali rischi.\\

%\begin{risk}{Performance del simulatore hardware}
%    \riskdescription{le performance del simulatore hardware e la comunicazione con questo potrebbero risultare lenti o non abbastanza buoni da causare il fallimento dei test}
%    \risksolution{coinvolgimento del responsabile a capo del progetto relativo il simulatore hardware}
%    \label{risk:hardware-simulator} 
%\end{risk}

%**************************************************************
\section{Sviluppo delle componenti critiche}
Durante lo sviluppo del modulo sono state identificati e risolti numerosi problemi, i più importanti tra questi sono stati illustrati di seguito.
\subsection{Design del modulo}

\subsubsection*{Problematica}
La prima difficoltà riscontrata consisteva nella scelta dell'archietettura del modulo. Questo infatti, come descritto precedentemente, 
doveva potersi integrare all'interno della piattaforma AMP. 

\subsubsection*{Soluzione adottata}
Ho deciso di strutturare il modulo in 2 \emph{package} principali: source e driver. Così facendo, ho potuto inserire tutto
il codice relativo all'integrazione con il \emph{framework} OSGi e con la piattaforma AMP in un'unico posto.
Questo ha permesso di poter astrarre il funzionamento del lettore, implementato all'interno del \emph{package} driver, rendendolo
di fatto invisibile ad ogni suo utilizzatore. Il vantaggio principale di questa soluzione è la portabilità del modulo stesso, questo
potrà essere riutilizzato con semplicità in futuri progetti cliente, indipendenti dalla piattaforma attualmente in uso.
Una visione d'insieme di questa organizzazione è visibile nella figura \ref{package_diag}. In questa si può notare che il \emph{package}
driver ne contenga a sua volta altri, specializzati per compito, completamente invisibili ad ogni possibile utilizzatore del
modulo.

\begin{figure}[!h] 
    \centering 
    \includegraphics[width=1\columnwidth]{tec/UML/package_diag.png} 
    \caption{Diagramma dei package del modulo}
    \label{package_diag}
\end{figure}

Al fine di rendere l'utilizzo del \emph{package} driver il più semplice possibile, ho deciso di utilizzare un \emph{pattern} progettuale
apposito, il \emph{command pattern}. Questo, come riportato in figura \ref{command_pattern}, permette di identificare le varie
funzionalità e capacità di una componente del codice come azioni o comandi analoghi a quelli che possiamo trovare sul telecomando
di un televisore. Ciò permette di utilizzare tutte le caratteristiche offerte dal lettore senza avere la necessità di conoscerne il
funzionamento specifico, semplificando di conseguenza l'applicazione della \emph{business logic} desiderata.
Oltre a ciò, tale \emph{pattern} è stato particolarmente adatto per la risultizione di altri problemi, uno di questi viene descritto
approfonditamente nella sezione \ref{sub-sec:DLS}.

%questi vengono descritti nelle sezioni \ref{sub-sec:DLS} e \ref{sub-sec:GPIO}.

\begin{figure}[!h] 
    \centering 
    \includegraphics[width=1\columnwidth]{tec/UML/command_pattern.png} 
    \caption{Diagramma UML del Command Pattern - \textbf{fonte} \url{urly.it/3gn4p}}
    \label{command_pattern}
\end{figure}

%**************************************************************
\subsection{Interfacciamento con librarie native}
\subsubsection*{Problematica}
La seconda difficoltà riscontrata consisteva nell'utilizzo delle librerie native offerte dal produttore dei lettori.
Questo era dovuto principalmente a 2 fattori. In primo luogo vi era l'accesso a tale codice direttamente dal modulo Java.
In secondo luogo vi era la differenza tra i paradigmi di programmazione utilizzati, ovvero, il paradigma procedurale ed il paradigma
orientato agli oggetti. 

%Come precedentamente descritto, il modulo avrebbe dovuto interfacciarsi con delle librerie native offerte dal produttore dei lettori.
%Nello specifico, queste librerie si sarebbe dovuto accedere direttamente dal codice Java. A complicare il tutto vi era la differenza tra i paradigmi di
%programmazione utilizzati per il modulo e per le librerie, ovvero, il paradigma orientato agli oggetti ed il paradigma procedurale. 
\subsubsection*{Soluzione adottata}
Per risolvere questo problema ho ricorso all'utilizzo della libreria JNA. Questa, tramite l'implementazione di interfacce ed oggetti appositi, 
permette di effettuare un \emph{wrap} del codice nativo andando a rendere disponibili tutti i tipi di dati primitivi all'interno 
dell'ecosistema JVM. Due esempi di come questo venga effettuato sono riportati nei frammenti di codice di seguito ripotati.
Il primo frammento mostra la conversione di un tipo enumeratore denominato CommunicationStandard da nativo a tipo JVM e la conversione
di una funzione nativa che utilizza tale tipo come parametro.
\begin{lstlisting}
    // RRU4JavaLibrary.java
    public abstract interface RRU4JavaLibrary extends Library {
        public abstract tReaderErrorCode SetCommunicationStandard(Pointer readerConnection, 
            tCommunicationStandard paramtCommunicationStandard);

        public static enum tCommunicationStandard {
            CS_None((byte)0), CS_Autodetect((byte)1), CS_ETSI_EN302208((byte)2), CS_ETSI_EN302208_LBT((byte)3), 
            CS_FCC((byte)4), CS_Special((byte)5), CS_China((byte)6), CS_Thailand((byte)7), CS_Brazil((byte)8), 
            CS_SouthKorea((byte)9), CS_Peru((byte)10), CS_Singapore((byte)11), CS_Australia((byte)12), CS_Japan((byte)13), 
            CS_Last((byte)14);
    
            private final byte value;
    
            private tCommunicationStandard(byte paramByte) {
                this.value = paramByte;
            }
            
            public byte getValue() {
                return this.value;
            }
        }
    }
\end{lstlisting}
Il secondo frammento, invece, mostra come venga effettuato il caricamente della libreria nativa a seconda della piattaforma
in cui il modulo viene eseguito.
\begin{lstlisting}
    // ReaderDllLoader.java
    public class ReaderDllLoader {
        
        public static RRU4JavaLibrary load(String pathToLib) {
		    Map<String, Object> options = new HashMap<String, Object>();
		    options.put(Library.OPTION_TYPE_MAPPER, new RRU4TypeMapper());
            NativeLibrary.addSearchPath("RRU4", pathToLib);
            return (RRU4JavaLibrary) Native.loadLibrary(
		        Platform.isWindows() ? "RRU4" : "ReaderLib",
		        RRU4JavaLibrary.class, options);
        }
    }
\end{lstlisting}

\label{callback}
Questo però non è stato sufficente a risolvere i problemi relativi ai differenti paradgmi di programmazione utilizzati. La libreria, infatti, era strutturata
in modo che ogni funzione richiamata ritornasse solo un codice di errore relativo alla libreria stessa. Ogni dato rilevante che ci si sarebbe potuti
aspettare come risultato, viene invece ricevuto come parametro di una funzione di \emph{callback}. Questo comporta una interruzione nel normale flusso di
chiamate dei metodi, con la conseguente necessità di gestione dei dati e degli errori.
Per ovviare a ciò ho provveduto ad utilizzare un \emph{Exchanger} fornito dalla libreria standard di Java. 
L'utilizzo di questo è visile nel frammento di codice di seguito riportato.

\begin{lstlisting}
    // ResultHandlerGetPortPower.java
    public class ResultHandlerGetPortPower extends BaseConfigurationHandler 
        implements tDllResultHandlerGetPortPower {
            @Override
            public void resultHandlerGetPortPower(tResultFlag enResultFlag, byte ubPort,
                    byte ubPortPower, Pointer rru4Handle, Pointer pTag) {
                if (enResultFlag != tResultFlag.RF_NoError) {
                    exchangeData(new ReaderStatus.StatusBuilder()
                            .withException(new ReaderException(
                                    "Error occured getting port power: " + enResultFlag,
                                    enResultFlag))
                            .build());
                } else {
                    exchangeData(new ReaderStatus.StatusBuilder()
                            .withPortConfig(new AntennaConfig(new Antenna[] {
                                    new Antenna(ubPort, ubPortPower / 4, 0) }))
                            .build());
                }
            }
    }

    // Reader.java
    public class Reader {
        
        public Antenna getPortPower(byte portNumber) throws InterruptedException {
		    tReaderErrorCode errorCode = libraryWrapper
		            .GetPortPower(connection.get().getHandler(), portNumber);
		    String MSG = "Error getting antenna power: " + errorCode;
		    checkErrors(errorCode, MSG);
		    ReaderStatus newStatus = exchanger.exchange(null);
		    checkCallBackErrors(newStatus);
		    AntennaConfig config = newStatus.getPortConfig();
		    Antenna port = config.getPort(portNumber);
		    return port;
	    }
    }
\end{lstlisting}

Nello specifico, all'arrivo di una \emph{callback}, la libreria JNA istanzia un nuovo \emph{thread} per elaborarla. 
Il primo processo che durante l'esecuzione raggiunge l'\emph{exchanger} viene messo in attesa finchè anche il secondo non
raggiunge il punto desiderato, instaurando di conseguenza una sincronia fra essi. Una volta che questa sincronia viene
creata avviene uno scambio di dati tramite oggetti che permette ai \emph{thread} di continuare con la loro normale
esecuzione.

%**************************************************************
\subsection{Gestione delle operazioni di lettura}
% Parlare del thread di lettura e della struttura producer-concumer utilizzata
\subsubsection*{Problematica}
Nonostante la sincronizzazione delle \emph{callback}, descritta nella sezione \ref{callback}, fornisca molteplici
vantaggi, pecca in quanto a prestazioni ed autonomia. Questo è dovuto in primo luogo alle aspettative sul funzionamento
del modulo, questo infatti deve poter essere utilizzabile, per esempio: dare informazioni sullo stato delle antenne, notificare
dati ad AMP, modificare delle configurazioni del lettore, ecc. Nonostante stia eseguendo delle operazioni di lettura.
Il secondo problema riscontrato è di natura invece più tecnica. Per come è stata implementata la libreria offerta dal produttore,
anche le operazioni di lettura restituiscono i dati desiderati tramite il meccanismo delle \emph{callback}. 
Questo comportamento obbliga la creazione di un nuovo \emph{thread} ogni volta che viene effetuata una lettura, rischiando quindi di saturare 
i \emph{thread} istanziabili dal sistema operativo in uso.

\subsubsection*{Soluzione adottata}
Per ovviare a questo problema ho deciso di trattare le \emph{callback} di lettura dati in modo diverso dalle altre. 
Nello specifico, il \emph{thread} che viene creato ad ogni chiamata, viene liberato il più velocemente possibile grazie all'utilizzo di un
"consumatore". Questo è un processo incaricato di raccogliere i dati delle letture tramite l'utilizzo una struttura sincronizzata, 
lasciando quindi che la \emph{callback} muoia il più velocemente possibile. Periodicamente questo processo provvederà l'invio di tali dati alla piattaforma AMP. 
Quanto descritto è visibile nel frammento di codice di seguito riportato.

\label{HandlerReading}
\begin{lstlisting}
    
    // ResultHandlerSyncReadDataUntilEndOfBankAny.java
    public class ResultHandlerSyncReadDataUntilEndOfBankAny
        implements tDllResultHandlerSyncReadDataUntilEndOfBankAny {

        @Override
        public void resultHandlerSyncReadDataUntilEndOfBankAny(
                tResultFlag enResultFlag, byte ubExtendedResultFlag,
                tEPCListEntry pEPCList, Pointer rru4Handle, Pointer pTag) {
            Builder readingBuilder = new Reading.Builder()
				    	    .withEPC(epc.toString())
					        .withReaderTimestamp(pEPCList.udwTimestamp)
					        .withAntenna(pEPCList.ubPort)
					        .withRSSI(pEPCList.ubRSSI);
            consumer.accept(readingBuilder.build());
        }
    }
    
    // KathreinConsumer.java
    public class KathreinConsumer {

        private final BlockingQueue<Reading> readQueue = new LinkedBlockingQueue<Reading>();
        private ConsumerAction thread;
        
        public void addToQueue(Reading t) {
		    readQueue.add(t);
	    }

        private class ConsumerAction extends TerminableYarn {
		    @Override
		    protected long doCycle() {
			    Collection<Reading> buffer = new ArrayList<>(readQueue.size());
			    readQueue.drainTo(buffer);
			    for (Reading item : buffer) {
				    lambda.accept(item.ampFormatMessage(ip, procName));
			    }
			    return reportPeriod;
		    }
	    }
    }
\end{lstlisting}

%Come visibile infatti dal frammento di codice \ref{HandlerReading}, i dati della lettura vengono utilizzati per la creazione
%di un oggetto apposito che viene inviato al consumatore. Questo, a sua volta, andrà ad inviare tali dati 
%**************************************************************
\subsection{Linguaggio di dominio specifico}
\label{sub-sec:DLS}
\subsubsection*{Problematica}
La quarta difficoltà riscontata consisteva in come gli utenti del modulo avrebbero potuto interfacciarsi con esso.
Questi sono composti dai tecnici che effettuano la configurazione dei lettori, e da altri moduli che ne modificano il funzionamento
in base a precise regole di \emph{business}. Per i primi è disponibile una finestra di dialogo all'interno di AMP che permette
di inviare stringhe di testo al modulo. Per gli altri moduli è possibile inviare sempre del testo
tramite delle apposite code all'interno di AMP. Entrambe le tipologie di interazione portano quindi alla chiamata del medesimo metodo.

\subsubsection*{Soluzione adottata}
Per creare un metodo di interazione che fosse univoco e facilmente mantenibile, ho quindi deciso di formalizzare un DLS, ovvero
un linguaggio di dominio specifico. Questo è un linguaggio di specifica utilizzabile per comandare il lettore, specificando uno o più
comandi concatenabili.

Per la creazione di tale linguaggio ho utilizzato la libreria \emph{open source} Parboiled. Questa fornisce tutto il necessario per l'implementazione
di un \emph{parser} PEG, Parsing Expression Grammar, direttamente all'interno del codice Java. In aggiunta a ciò viene fornita un'implementazione di un \emph{parser} ricorsivo discendente ed il
supporto per la costruzione di: \emph{abstract syntax tree}, report sugli errori di analisi e procedure di recupero in caso di errore.
Simile ad un \gls{cfgg}, PEG è una grammatica formale analitica deterministica, che descrive un linguaggio formale in termini di un insieme di regole per riconoscere
le stringhe che appartengono al linguaggio.
Nel frammento di codice, di seguito riportato, è possibile vedere come la libreria venga utilizzata per per la creazione di una parte della grammatica.
Questo, unito all'utilizzo del \emph{Command Pattern} descritto in precedenza, permette la creazione di comandi eseguibili partendo esclusivamente da testo.
\begin{lstlisting}
    // QueryParser.java
    @BuildParseTree
    public class QueryParser extends BaseParser<Object> {
        
        public Rule input() {
		    return OneOrMore(Command(), FirstOf(Ch('\n'), EOI));
	    }

	    public Rule Command() {
		    return FirstOf(StartReading(), StopReading(), SetPortPower(),
		            GetPortPower(), SetGPO());
	    }

        public Rule SetPortPower() {
		    return Sequence(QRY_SET_POWER, whiteSpaces(), Arg(), whiteSpaces(),
		            Arg(), Optional(whiteSpaces()),
		            Boolean.valueOf(push(new SetAntennaPowerCommand(reader, kpl,
		                    CommandType.CONF, ((Integer) pop(1)).intValue(),
		                    ((Integer) pop()).intValue()))));
	    }

        public Rule Arg() {
		    return number();
	    }

	    public Rule number() {
		    return Sequence(OneOrMore(CharRange('0', '9')),
		            Boolean.valueOf(push(new Integer(match()))));
	    }

	    public Rule whiteSpaces() {
		    return OneOrMore(Ch(' '));
	    }
    }
\end{lstlisting}

%**************************************************************
%\subsection{Controllo delle porte GPIO}
%\label{sub-sec:GPIO}
%Qui parlo del command pattern utilizzato per tutte le interazioni e nello specifico quello delle porte GPIO
\subsection{Tolleranza ai guasti}
\subsubsection*{Problematica}
La quinta difficoltà consisteva nella gestione dei guasti dovuti alla disconnessione del lettore dal modulo.
Il problema è scomponibile in 3 problemi più piccoli, quali:
\begin{itemize}
    \item Identificazione del guasto
    \item Procedura di arresto delle operazioni di lettura
    \item Ripristino dello stato del lettore in caso di nuova connessione
\end{itemize}

\subsubsection*{Soluzione adottata}
Per agevolare la gestione della connessione ho quindi provveduto ad implementare un \emph{thread} indipendente,
chiamato ConnectionManager, avente il solo scopo di effettuare connessione, disconnessione e controllare che questa sia ancora valida e attiva.
Un frammento di codice relativo al funzionamento di questo è di seguito riportato. 
\begin{lstlisting}
    // ConnectionManager.java
    public class ConnectionManager {

        private final AtomicReference<Connection> connection;
        private ReconnectionThread reconnectionThread;
        private final Runnable reconnectionSignal;

        public boolean isConnectionAlive() {
		    return connection.get().isValid();
	    }

        private boolean attemptConnection() throws Exception {
		    Thread.sleep(reconnectionSleep);
		    try {
			    boolean connected = connect().get().isValid();
			    return connected;
		    } catch (ConnectException ex) {
			    throw new ConnectException("Re-connection failed");
		    }
	    }

        private class ReconnectionThread extends TerminableYarn {
            @Override
            protected long doCycle() {
                if (isConnectionAlive())
                    return 1000;
                try {
                    boolean reconnected = attemptConnection();
                    if (reconnected)
                        reconnectionSignal.run();
                } catch (Exception e) {
                    kpl.info("In attempting (re)connection: " + e.getMessage());
                    return reconnectionSleep;
                }
                return 1000;
            }
	    }
	}
\end{lstlisting}
Come è visibile, ogni secondo il \emph{thread} controlla che l'oggetto relativo alla connessione sia ancora valido.
Nel caso in cui questo sia stato invalidato da una \emph{callback} apposita, andrà a tentare una riconnessione, che
nel caso avesse successo, segnalerà al modulo la necessità di riconfigurare il lettore.
La configurazione viene effettuata eseguendo nuovamente i comandi di configurazione che sono stati lanciati dall'avvio
del modulo. Affinchè questa lista di comandi non presenti ripetizioni inutili, prima di ogni inserimento viene effettuata
una riduzione di tale lista. Di seguito viene riportato un frammento del codice responsabile di queste operazioni.
\begin{lstlisting}
    // ConfigurationCommandHistory.java
    public class ConfigurationCommandHistory {

        private final List<DriverCommand> commandsHistory = new ArrayList<>(3);

        public void addCommand(DriverCommand command) {
            if (command.getType() != CommandType.CONF)
                return;
            addCommandAndreduceHistory(command);
        }

        public void executeConfHistory() throws Exception {
            Iterator<DriverCommand> it = commandsHistory.iterator();
            while (it.hasNext()) {
                it.next().execute();
            }
        }

        private void addCommandAndreduceHistory(DriverCommand command) {
            for (int i = 0; i < commandsHistory.size(); i++) {
                DriverCommand cur = commandsHistory.get(i);
                if (command.isSameCommand(cur)) {
                    commandsHistory.set(i, command);
                    return;
                }
            }
            commandsHistory.add(command);
        }
    }

    public class Reader {

        private void reconfigureReader() {
			history.executeConfHistory();
			kpl.info("Reader re-configured and ready to use");
		}
	}
    }
\end{lstlisting}

%**************************************************************
\section{Risultati raggiunti}
\subsection{Requisiti soddisfatti}
Un elemento oggettivo, per descrivere la completezza del codice richiesto, riguarda la copertura dei requisiti maturati durante lo stage.
L’azienda, avendo già esperienza con progretti analoghi, non ha ritenuto necessario richiedere funzionalità 
desiderabili o opzionali. Considerando infatti, tutte le richieste fatte come necessarie affinchè il prodotto sviluppato potesse essere utilizzabile
all'interno delle loro soluzioni aziendali.
Conseguentemente a ciò, i requisiti funzionali, di vincolo e qualitativi, sono risultati essere tutti \textbf{obbligatori}.
In sezione \ref{sub-sec:req} sono stati elencati solamente i requisiti degni di nota che però non rappresentano la totalità di quelli 
effettivamente da soddisfare.
La tabella \ref{tab:req-solved} a seguito, invece, rappresenta la totalità dei requisiti individuati con l’azienda.
\begin{table}[h!]
    \begin{tabularx}{\textwidth}{ | X | c | c | c | }
    \hline
    \textbf{Tipologia requisiti} & \textbf{Numero requisiti} & \textbf{Classificazione} & \textbf{Soddisfatti}\\
    \hline
    Funzionali & 26 & Obbligatori & 26 \\
    \hline
    Vincolo & 5 & Obbligatori & 5 \\
    \hline
    Qualitativi & 2 & Obbligatori & 2 \\
    \hline
    \end{tabularx}
    \caption{Piano di lavoro}
    \label{tab:req-solved}
\end{table}

\subsection{Prodotti creati}
Un altro elemento oggettivo sul lavoro svolto è sicuramente la quantità di prodotti creati. 
Nel caso specifico ho prodotto diversi file sorgente per un totale di circa 3600 righe di codice, ognuno di essi corredato
con l'opportuna documentazione sotto forma di Java-doc. In aggiunta a questo ho redatto 3 documenti, uno riguardante l'utilizzo
della libreria JNA e due riguardanti le parti più rilevanti del modulo.